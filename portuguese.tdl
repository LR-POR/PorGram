;;; -*- Mode: TDL; Coding: utf-8 -*-
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Grammar of Portuguese
;;; created at:
;;;     Thu Oct 07 19:37:45 UTC 2021
;;; based on Matrix customization system version of:
;;;     Mon Aug  2 23:22:15 UTC 2021
;;;
;;; see https://github.com/LR-POR/PorGram
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Type assigning empty mod list. Added to basic types for nouns, verbs and determiners.

non-mod-lex-item := lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < > ].

;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Matrix Type Addenda
;;;;;;;;;;;;;;;;;;;;;;;;;

png :+ [ DIM bool,
    AUG bool,
    ABS bool,
    HUM bool,
    PER person,
    NUM number,
    GEND gender ].

basic-head-comp-phrase :+ [ SYNSEM [ LIGHT #light,
             LOCAL.CAT [ HC-LIGHT #light,
                         MC #mc ] ],
    HEAD-DTR.SYNSEM.LOCAL.CAT.MC #mc ].

head :+ [ PRON bool,
    AUX bool,
    PRD bool,
    NMZ bool,
    FORM form,
    INIT bool ].

noun :+ [ CASE case ].

inflected :+ [ N-NUM-FLAG luk,
    REFL-FLAG luk,
    DET-GEND-FLAG luk,
    UNIFORM-ADJ-FLAG luk,
    A-GEND-FLAG luk,
    DET-NUM-FLAG luk,
    NON-UNIFORM-ADJ-FLAG luk,
    TMP-FLAG luk,
    AUX-OR-ESTAR-AUX-OR-IR-AUX-OR-NONINH-REFL-VERB-OR-TER-AUX-FLAG luk,
    A-NUM-FLAG luk,
    COP-TMP-FLAG luk,
    INH-REFL-VERB-FLAG luk ].

infl-satisfied :+ [ N-NUM-FLAG na-or-+,
    REFL-FLAG na-or-+,
    DET-GEND-FLAG na-or-+,
    UNIFORM-ADJ-FLAG na-or-+,
    A-GEND-FLAG na-or-+,
    DET-NUM-FLAG na-or-+,
    NON-UNIFORM-ADJ-FLAG na-or-+,
    TMP-FLAG na-or-+,
    AUX-OR-ESTAR-AUX-OR-IR-AUX-OR-NONINH-REFL-VERB-OR-TER-AUX-FLAG na-or-+,
    A-NUM-FLAG na-or-+,
    COP-TMP-FLAG na-or-+,
    INH-REFL-VERB-FLAG na-or-+ ].

basic-head-opt-subj-phrase :+ [ HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < > ].

basic-head-mod-phrase-simple :+ [ SYNSEM.LOCAL.CAT.MC #mc,
    HEAD-DTR.SYNSEM.LOCAL.CAT.MC #mc ].

adj-head-int-phrase :+ [ HEAD-DTR.SYNSEM.NON-LOCAL.SLASH.LIST < > ].

;;;;;;;;;;;;;;
;;; Features
;;;;;;;;;;;;;;

;;; Case

case := *top*.
nom := case.  ; nom
acc := case.  ; acc

;;; Person

person := *top*.
1st := person.
2nd := person.
3rd := person.

;;; Number

number := *top*.
singular := number.
plural := number.

;;; Gender

gender := *top*.
masculine := gender.
feminine := gender.

;;; Form

form := *top*.
nonfinite := form.
finite := form.
present_participle := nonfinite.
past_participle := nonfinite.
infinitive := nonfinite.
infl_infinitive := nonfinite.
que := form.
com_que := form.
para_que := form.
em_que := form.

;;; Tense

past := tense.
perfect := past.
imperfect := past.
pluperfect := past.
present := tense.
future := tense.
present-future := future.
preterite-future := future.

;;; Aspect

perfective := aspect.
imperfective := aspect.
progressive := imperfective.

;;; Mood

subjunctive := mood.
indicative := mood.

;;;;;;;;;;;;;;;;;;;
;;; Lexical Types
;;;;;;;;;;;;;;;;;;;

;;; Nouns

wh-pronoun-noun-lex := basic-wh-word-lex & norm-hook-lex-item & basic-icons-lex-item & non-mod-lex-item & zero-arg-que &
  [ SYNSEM [ LOCAL [ CAT [ HEAD noun,
                           VAL [ SPR < >,
                                 SUBJ < >,
                                 COMPS < >,
                                 SPEC < > ] ],
                     CONT [ RELS.LIST < [ LBL #larg,
                                          ARG0 ref-ind & #arg0 ],
                                        quant-relation &
                                        [ PRED "which_q_rel",
                                          ARG0 #arg0,
                                          RSTR #harg ] >,
                            HCONS.LIST < [ HARG #harg,
                                           LARG #larg ] > ] ],
             NON-LOCAL.QUE.LIST < #arg0 > ] ].

noun-lex := basic-noun-lex & basic-non-wh-word-lex & non-local-none-lex-item & no-hcons-lex-item & non-mod-lex-item &
  [ ARG-ST < #spr >,
    SYNSEM.LOCAL.CAT [ VAL [ SPR < #spr &
                                   [ LOCAL.CAT.HEAD det ] >,
                             COMPS < >,
                             SUBJ < >,
                             SPEC < > ],
                       HEAD.NMZ - ] ].

no-spr-noun-lex := noun-lex &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < [ OPT + ] > ].

; Nouns which cannot take specifiers mark their SPR requirement
; as OPT +.  Making the non-head daughter OPT - in this rule
; keeps such nouns out.
; 
; Rules for building NPs.  Note that the Matrix uses SPR for
; the specifier of nouns and SUBJ for the subject (specifier) of verbs.

head-spec-phrase := basic-head-spec-phrase & head-final &
  [ NON-HEAD-DTR.SYNSEM.OPT - ].

pers-pron-noun-lex := no-spr-noun-lex &
  [ SYNSEM.LOCAL.CAT.HEAD.PRON + ].

nom-pers-pron-1s-noun-lex := pers-pron-1-noun-lex & pers-pron-sg-noun-lex & nom-pers-pron-noun-lex.

pers-pron-3pm-noun-lex := pers-pron-3-noun-lex & pers-pron-pl-noun-lex & pers-pron-masc-noun-lex.

common-noun-lex := noun-lex &
  [ INFLECTED.N-NUM-FLAG - ].

fem-noun-lex := common-noun-lex &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.GEND feminine ].

masc-noun-lex := common-noun-lex &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.GEND masculine ].

dim-noun-lex := common-noun-lex &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.DIM + ].

dim-masc-noun-lex := dim-noun-lex.

dim-fem-noun-lex := fem-noun-lex & dim-noun-lex.

aug-noun-lex := common-noun-lex &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.AUG + ].

aug-fem-noun-lex := fem-noun-lex & aug-noun-lex.

aug-masc-noun-lex := masc-noun-lex & aug-noun-lex.

inter-pron-noun-lex := wh-pronoun-noun-lex &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG [ NUM singular,
                                       PER 3rd ] ].

inter-pron-hum-noun-lex := inter-pron-noun-lex &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.HUM + ].

inter-pron-non-hum-noun-lex := inter-pron-noun-lex.

pers-pron-3-noun-lex := pers-pron-noun-lex &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PER 3rd ].

pers-pron-1-noun-lex := pers-pron-noun-lex &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PER 1st ].

pers-pron-2-noun-lex := pers-pron-noun-lex &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PER 2nd ].

pers-pron-sg-noun-lex := pers-pron-noun-lex.

pers-pron-pl-noun-lex := pers-pron-noun-lex.

nom-pers-pron-2s-noun-lex := pers-pron-2-noun-lex & pers-pron-sg-noun-lex & nom-pers-pron-noun-lex.

pers-pron-1p-noun-lex := pers-pron-1-noun-lex & pers-pron-pl-noun-lex.

pers-pron-masc-noun-lex := pers-pron-noun-lex.

pers-pron-fem-noun-lex := noun-lex.

pers-pron-3pf-noun-lex := pers-pron-3-noun-lex & pers-pron-pl-noun-lex & pers-pron-fem-noun-lex.

pers-pron-3sm-noun-lex := pers-pron-3-noun-lex & pers-pron-sg-noun-lex & pers-pron-masc-noun-lex.

pers-pron-3sf-noun-lex := pers-pron-3-noun-lex & pers-pron-sg-noun-lex & pers-pron-masc-noun-lex.

dim-aug-noun-lex := dim-noun-lex & aug-noun-lex.

dim-aug-masc-noun-lex := masc-noun-lex & dim-aug-noun-lex.

dim-aug-fem-noun-lex := fem-noun-lex & dim-aug-noun-lex.

pers-pron-2pl-noun-lex := pers-pron-2-noun-lex & pers-pron-pl-noun-lex.

proper-noun-noun-lex := noun-lex &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG [ NUM singular,
                                       PER 3rd ] ].

nom-pers-pron-noun-lex := pers-pron-noun-lex &
  [ SYNSEM.LOCAL.CAT.HEAD.CASE nom ].

;;; Verbs

; verb-lex is HC-LIGHT - to allow us to pick out
; 
;   lexical Vs for V-level attachment of negative adverbs.

verb-lex := non-mod-lex-item &
  [ SYNSEM [ L-QUE -,
             LOCAL.CAT [ HEAD verb &
                              [ NMZ - ],
                         HC-LIGHT - ] ] ].

main-verb-lex := verb-lex & basic-verb-lex & basic-non-wh-word-lex &
  [ SYNSEM [ L-QUE -,
             LOCAL [ CAT [ HEAD.AUX -,
                           VAL [ SPEC < >,
                                 SUBJ < #subj > ] ],
                     CONT.HOOK.XARG #xarg ] ],
    ARG-ST.FIRST #subj &
                 [ LOCAL [ CAT cat-sat &
                               [ VAL [ SPR < >,
                                       COMPS < > ] ],
                           CONT.HOOK.INDEX #xarg ] ] ].

aux-lex := verb-lex & basic-icons-lex-item & refl-rule-dtr & tmp-rule-dtr &
  [ SYNSEM [ LOCAL.CAT.HEAD.AUX +,
             L-QUE - ],
    INFLECTED [ TMP-FLAG -,
                REFL-FLAG -,
                AUX-OR-ESTAR-AUX-OR-IR-AUX-OR-NONINH-REFL-VERB-OR-TER-AUX-FLAG + ] ].

intransitive-verb-lex := main-verb-lex & intransitive-lex-item &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < >,
    ARG-ST.FIRST.LOCAL.CAT.HEAD noun ].

;transitive-verb-lex := main-verb-lex & transitive-lex-item &
;  [ SYNSEM.LOCAL.CAT.VAL.COMPS < #comps >,
;    ARG-ST < [ LOCAL.CAT.HEAD noun ],
;             #comps &
;             [ LOCAL.CAT cat-sat &
;                         [ VAL [ SPR < >,
;                                 COMPS < > ],
;                           HEAD noun ] ] > ].

clausal-verb-lex := main-verb-lex &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < #comps >,
    ARG-ST < [ LOCAL.CAT.HEAD noun ],
             #comps &
             [ LOCAL.CAT [ MC na-or--,
                           VAL [ SPR < >,
                                 COMPS < >,
                                 SUBJ < > ] ] ] > ].

nom-intransitive-verb-lex := intransitive-verb-lex &
  [ ARG-ST.FIRST.LOCAL.CAT.HEAD noun &
                                [ CASE nom ] ].

nom-acc-transitive-verb-lex := transitive-verb-lex &
  [ ARG-ST < [ LOCAL.CAT.HEAD noun &
                              [ CASE nom ] ],
             [ LOCAL.CAT.HEAD noun &
                              [ CASE acc ] ] > ].

clausal-nom-verb-lex := clausal-verb-lex &
  [ ARG-ST.FIRST.LOCAL.CAT.HEAD noun &
                                [ CASE nom ] ].

intrans-verb-lex := regular-verb-lex & nom-intransitive-verb-lex.

vol-verb-lex := que-subj-cl-verb-lex.

quest-verb-lex := noninh-refl-verb-lex & quest-cl-verb-lex.

refl-quest-verb-lex := inh-refl-verb-lex & quest-cl-verb-lex.

inh-refl-verb-lex := regular-verb-lex &
  [ INFLECTED.INH-REFL-VERB-FLAG + ].

regular-verb-lex := verb-lex & refl-rule-dtr & tmp-rule-dtr &
  [ INFLECTED [ TMP-FLAG -,
                REFL-FLAG - ] ].

trans-verb-lex := noninh-refl-verb-lex & nom-acc-transitive-verb-lex.

mental-act-verb-lex := que-cl-verb-lex.

noninh-refl-verb-lex := regular-verb-lex &
  [ INFLECTED.AUX-OR-ESTAR-AUX-OR-IR-AUX-OR-NONINH-REFL-VERB-OR-TER-AUX-FLAG + ].

declar-verb-lex := ind-cl-verb-lex.

refl-int-verb-lex := intrans-verb-lex & inh-refl-verb-lex.

inf-eval-verb-lex := inf-cl-verb-lex.

nonrefl-int-verb-lex := intrans-verb-lex & noninh-refl-verb-lex.

fac-refl-int-verb-lex := intrans-verb-lex.

que-eval-verb-lex := que-subj-cl-verb-lex.

que-cl-verb-lex := fin-cl-verb-lex & clausal-nom-verb-lex & clausal-second-arg-trans-lex-item &
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS < [ LOCAL [ CAT [ HEAD comp &
                                                        [ FORM que ],
                                                   WH.BOOL - ],
                                             CONT.HOOK.INDEX.SF prop ] ] >,
             NON-LOCAL.QUE.LIST < > ] ].

que-subj-cl-verb-lex := que-cl-verb-lex & subj-cl-verb-lex.

; ind-cl-verb-lex := que-cl-verb-lex.

quest-cl-verb-lex := regular-verb-lex & clausal-nom-verb-lex & clausal-second-arg-trans-lex-item &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL [ CONT.HOOK.INDEX [ E.MOOD indicative,
                                                             SF ques ],
                                           CAT [ HEAD +vc &
                                                      [ FORM finite ],
                                                 WH.BOOL + ] ] ] > ].

fin-cl-verb-lex := noninh-refl-verb-lex.

com-que-caus-verb-lex := subj-cl-verb-lex & clausal-nom-verb-lex & clausal-second-arg-trans-lex-item &
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS < [ LOCAL [ CAT [ HEAD comp &
                                                        [ FORM com_que ],
                                                   WH.BOOL - ],
                                             CONT.HOOK.INDEX.SF prop ] ] >,
             NON-LOCAL.QUE.LIST < > ] ].

que-caus-verb-lex := que-subj-cl-verb-lex.

que-percep-verb-lex := ind-cl-verb-lex.

fact-mental-act-verb-lex := ind-cl-verb-lex.

inf-cl-verb-lex := noninh-refl-verb-lex & clausal-nom-verb-lex & clausal-second-arg-trans-lex-item &
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS < [ LOCAL [ CAT [ HEAD verb &
                                                        [ FORM infl_infinitive ],
                                                   WH.BOOL - ],
                                             CONT.HOOK.INDEX.SF prop ] ] >,
             NON-LOCAL.QUE.LIST < > ] ].

inf-caus-verb-lex := inf-cl-verb-lex.

inf-percep-verb-lex := inf-cl-verb-lex.

; subj-cl-verb-lex := fin-cl-verb-lex.

para-que-cl-verb-lex := subj-cl-verb-lex & clausal-nom-verb-lex & clausal-second-arg-trans-lex-item &
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS < [ LOCAL [ CAT [ HEAD comp &
                                                        [ FORM para_que ],
                                                   WH.BOOL - ],
                                             CONT.HOOK.INDEX.SF prop ] ] >,
             NON-LOCAL.QUE.LIST < > ] ].

em-que-cl-verb-lex := subj-cl-verb-lex & clausal-nom-verb-lex & clausal-second-arg-trans-lex-item &
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS < [ LOCAL [ CAT [ HEAD comp &
                                                        [ FORM em_que ],
                                                   WH.BOOL - ],
                                             CONT.HOOK.INDEX.SF prop ] ] >,
             NON-LOCAL.QUE.LIST < > ] ].

; dat-obj-verb-lex := noninh-refl-verb-lex & prep-obj-verb-lex.

dir-verb-lex := que-subj-cl-verb-lex.

; prep-obj-verb-lex := transitive-verb-lex.

; gen-obj-verb-lex := prep-obj-verb-lex.

refl-gen-obj-verb-lex := inh-refl-verb-lex & gen-obj-verb-lex.

nonrefl-gen-obj-verb-lex := noninh-refl-verb-lex & gen-obj-verb-lex.

;;; Auxiliaries

subj-raise-aux := aux-lex & trans-first-arg-raising-lex-item &
  [ SYNSEM.LOCAL [ CAT.VAL [ SPEC < >,
                             COMPS < #comps >,
                             SUBJ < #subj > ],
                   CONT.HOOK.XARG #xarg ],
    ARG-ST < #subj &
             [ LOCAL [ CAT [ HEAD noun &
                                  [ CASE nom ],
                             VAL [ SUBJ < >,
                                   SPR < >,
                                   SPEC < >,
                                   COMPS < > ] ],
                       CONT.HOOK.INDEX #xarg ] ],
             #comps &
             [ LOCAL.CAT [ VAL [ SUBJ < unexpressed >,
                                 COMPS < >,
                                 SPR < >,
                                 SPEC < > ],
                           HEAD verb ] ] > ].

subj-raise-aux-with-pred := subj-raise-aux & norm-sem-lex-item & trans-first-arg-raising-lex-item-1.

ter-aux-lex := subj-raise-aux-with-pred &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.FORM past_participle,
    INFLECTED.AUX-OR-ESTAR-AUX-OR-IR-AUX-OR-NONINH-REFL-VERB-OR-TER-AUX-FLAG + ].

estar-aux-lex := subj-raise-aux-with-pred &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.FORM present_participle,
    INFLECTED.AUX-OR-ESTAR-AUX-OR-IR-AUX-OR-NONINH-REFL-VERB-OR-TER-AUX-FLAG + ].

ir-aux-lex := subj-raise-aux-with-pred &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.FORM infinitive,
    INFLECTED.AUX-OR-ESTAR-AUX-OR-IR-AUX-OR-NONINH-REFL-VERB-OR-TER-AUX-FLAG + ].

bare-inf-aux-lex := subj-raise-aux-with-pred &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.FORM infinitive ].

ger-aux-lex := subj-raise-aux-with-pred &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.FORM present_participle ].

;;; Copulas

cop-lex := basic-verb-lex-super & trans-first-arg-raising-lex-item-2 & non-mod-lex-item &
  [ SYNSEM.LOCAL [ CAT.VAL [ SUBJ < [ LOCAL [ CONT.HOOK.INDEX #xarg,
                                              CAT cat-sat &
                                                  [ VAL [ SPR < >,
                                                          COMPS < > ],
                                                    HEAD noun ] ] ] >,
                             COMPS < [ LOCAL.CAT cat-sat &
                                                 [ HEAD.PRD +,
                                                   VAL [ SUBJ < >,
                                                         COMPS < > ] ] ] >,
                             SPEC < > ],
                   CONT.HOOK.XARG #xarg ],
    INFLECTED.COP-TMP-FLAG - ].

; Copula type taking adjectival complements.
; Need to define more for additional complement types.

adj-comp-copula-verb-lex := cop-lex &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD adj ].

ser-cop-lex := adj-comp-copula-verb-lex.

estar-cop-lex := adj-comp-copula-verb-lex.

;;; Adjectives

adj-lex := basic-intersective-adjective-lex.

infl-form-adj-lex := attr-adj-lex &
  [ SYNSEM.LOCAL.CAT [ VAL.SUBJ < >,
                       HEAD.PRD + ] ].

non-infl-form-adj-lex := attr-adj-lex & a-num-rule-dtr &
  [ SYNSEM.LOCAL.CAT [ VAL.SUBJ < >,
                       HEAD.PRD + ],
    INFLECTED [ A-GEND-FLAG -,
                A-NUM-FLAG - ] ].

non-unif-dim-adj-lex := non-uniform-adj-lex &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG.PNG.DIM + ].

aug-adj-lex := non-uniform-adj-lex &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG.PNG.AUG + ].

abs-adj-lex := non-uniform-adj-lex &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG.PNG.ABS + ].

uniform-adj-lex := non-infl-form-adj-lex &
  [ INFLECTED.UNIFORM-ADJ-FLAG + ].

non-uniform-adj-lex := non-infl-form-adj-lex &
  [ INFLECTED.NON-UNIFORM-ADJ-FLAG + ].

dim-aug-adj-lex := non-unif-dim-adj-lex & aug-adj-lex.

unif-dim-adj-lex := uniform-adj-lex &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG.PNG.DIM + ].

fem-dim-adj-lex := uniform-adj-lex &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG.PNG [ GEND feminine,
                                      DIM + ] ].

masc-dim-adj-lex := uniform-adj-lex &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG.PNG [ GEND masculine,
                                      DIM + ] ].

; Basic attributive adjective definition

attr-adj-lex := adj-lex & intersective-mod-lex &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT [ HEAD noun,
                                              VAL.SPR cons ] ] > ].

;;;;;;;;;;;;;;;;;;;
;;; Subordinators
;;;;;;;;;;;;;;;;;;;

adposition-subord-lex-item := single-rel-lex-item & norm-ltop-lex-item & basic-icons-lex-item &
  [ SYNSEM.LOCAL.CAT [ MC -,
                       HEAD adp &
                            [ MOD < [ LOCAL scopal-mod &
                                            [ CAT [ HEAD verb,
                                                    VAL.COMPS < > ] ] ] > ],
                       VAL [ SUBJ < >,
                             SPR < >,
                             SPEC < >,
                             COMPS < [ OPT -,
                                       LOCAL.CAT [ MC -,
                                                   VAL.COMPS < > ] ] > ] ] ].

subord-with-verbal-comp-lex := adposition-subord-lex-item &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MOD < [ LOCAL [ CAT.HEAD verb,
                                                CONT.HOOK [ LTOP #mod,
                                                            INDEX #index ] ] ] >,
                           VAL.COMPS < [ LOCAL [ CAT.HEAD verb,
                                                 CONT.HOOK.LTOP #comps ] ] > ],
                     CONT [ HCONS.LIST < qeq &
                                         [ HARG #h1,
                                           LARG #mod ],
                                         qeq &
                                         [ HARG #h2,
                                           LARG #comps ] >,
                            HOOK.INDEX #index ] ],
             LKEYS.KEYREL [ ARG1 #h1,
                            ARG2 #h2 ] ] ].

finite-clause-init-s-attach-subord-lex-item := subord-with-verbal-comp-lex &
  [ SYNSEM.LOCAL.CAT [ VAL.COMPS < [ LOCAL.CAT [ VAL.SUBJ < >,
                                                 HEAD.FORM #feat & finite ] ] >,
                       HEAD [ FORM #feat,
                              MOD < [ LOCAL.CAT.VAL.SUBJ < > ] >,
                              INIT + ] ] ].

;;; Complementizers

; We treat question particles as complementizers.
; Here is the lexical type for complementizers.

complementizer-lex-item := raise-sem-lex-item & non-local-none-lex-item & basic-icons-lex-item &
  [ SYNSEM.LOCAL.CAT [ HEAD comp &
                            [ MOD < > ],
                       VAL [ SPR < >,
                             SPEC < >,
                             SUBJ < >,
                             COMPS < #comp > ] ],
    ARG-ST < #comp &
             [ LOCAL.CAT [ HEAD verb,
                           VAL [ SUBJ < >,
                                 COMPS < > ] ] ] > ].

; Subtype for question particles. Constrains SF to ques.

qpart-lex-item := complementizer-lex-item &
  [ SYNSEM.LOCAL [ CONT.HOOK.INDEX.SF ques,
                   CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.FORM finite ] ].

q-particle1-lex := qpart-lex-item &
  [ SYNSEM.LOCAL.CAT [ MC #mc,
                       VAL.COMPS.FIRST.LOCAL.CAT [ MC #mc & +,
                                                   WH.BOOL - ] ] ].

comps1-complementizer-lex-item := complementizer-lex-item & basic-non-wh-word-lex &
  [ SYNSEM.LOCAL [ CAT [ MC na-or--,
                         VAL.COMPS.FIRST.LOCAL.CAT [ MC -,
                                                     HEAD.FORM finite ],
                         HEAD.FORM que ],
                   CONT.HOOK.INDEX.SF prop ] ].

comps3-complementizer-lex-item := complementizer-lex-item & basic-wh-word-lex &
  [ SYNSEM.LOCAL [ CONT.HOOK.INDEX.SF ques,
                   CAT [ MC na-or--,
                         VAL.COMPS.FIRST [ LOCAL [ CONT.HOOK.INDEX.E.MOOD indicative,
                                                   CAT [ MC -,
                                                         HEAD.FORM finite ] ],
                                           NON-LOCAL.QUE.LIST < > ] ] ] ].

comps5-complementizer-lex-item := complementizer-lex-item & basic-non-wh-word-lex &
  [ SYNSEM.LOCAL [ CAT [ MC na-or--,
                         VAL.COMPS.FIRST.LOCAL [ CAT [ MC -,
                                                       HEAD.FORM finite ],
                                                 CONT.HOOK.INDEX.E.MOOD subjunctive ],
                         HEAD.FORM com_que ],
                   CONT.HOOK.INDEX.SF prop ] ].

comps6-complementizer-lex-item := complementizer-lex-item & basic-non-wh-word-lex &
  [ SYNSEM.LOCAL [ CAT [ MC na-or--,
                         VAL.COMPS.FIRST.LOCAL [ CAT [ MC -,
                                                       HEAD.FORM finite ],
                                                 CONT.HOOK.INDEX.E.MOOD subjunctive ],
                         HEAD.FORM para_que ],
                   CONT.HOOK.INDEX.SF prop ] ].

comps7-complementizer-lex-item := complementizer-lex-item & basic-non-wh-word-lex &
  [ SYNSEM.LOCAL [ CAT [ MC na-or--,
                         VAL.COMPS.FIRST.LOCAL [ CAT [ MC -,
                                                       HEAD.FORM finite ],
                                                 CONT.HOOK.INDEX.E.MOOD subjunctive ],
                         HEAD.FORM em_que ],
                   CONT.HOOK.INDEX.SF prop ] ].

; Do not allow extracting "And Kim"

basic-head-filler-phrase :+ [ ARGS < [ SYNSEM.LOCAL.COORD - ],
           [ SYNSEM.LOCAL.COORD - ] > ].

extracted-comp-phrase := basic-extracted-comp-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ cons ].

extracted-subj-phrase := basic-extracted-subj-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < >,
    SYNSEM.LOCAL.CAT.HEAD verb ].

; Subject extraction

phrase-or-lexrule :+ [ SYNSEM.L-QUE #lque,
    ARGS.FIRST.SYNSEM.L-QUE #lque ].

insitu-int-cl := interrogative-clause & head-only &
  [ C-CONT [ RELS.LIST < >,
             HCONS.LIST < > ],
    SYNSEM [ MODIFIED hasmod,
             NON-LOCAL [ SLASH.LIST < >,
                         QUE.LIST < >,
                         REL.LIST < > ],
             LOCAL.CAT [ VAL #val,
                         MC bool,
                         WH.BOOL - ] ],
    HEAD-DTR.SYNSEM [ LOCAL.CAT [ HEAD verb,
                                  VAL #val &
                                      [ SUBJ < >,
                                        COMPS < > ] ],
                      NON-LOCAL [ SLASH.LIST < >,
                                  REL.LIST < >,
                                  QUE.LIST.FIRST ref-ind ],
                      L-QUE - ] ].

;;; Others

norm-adposition-lex := norm-sem-lex-item & no-hcons-lex-item & basic-intersective-mod-lex & non-local-none-lex-item &
  [ ARG-ST < #comp >,
    SYNSEM [ LKEYS.KEYREL arg12-ev-relation &
                          [ PRED #pred,
                            ARG2 #ind ],
             L-QUE #lque,
             LOCAL [ CONT.RELS.LIST < [ PRED #pred,
                                        ARG0 event,
                                        ARG1 event-or-ref-index ] >,
                     CAT [ WH.BOOL -,
                           HEAD adp &
                                [ MOD < [ LOCAL.CAT [ VAL.SPR cons,
                                                      WH.BOOL -,
                                                      HEAD.AUX - ] ] > ],
                           VAL [ SPR < >,
                                 SPEC < >,
                                 SUBJ < >,
                                 COMPS < #comp &
                                         [ L-QUE #lque,
                                           LOCAL [ CAT [ HEAD noun,
                                                         VAL.SPR < > ],
                                                   CONT.HOOK.INDEX #ind ],
                                           NON-LOCAL.SLASH.LIST < > ] > ] ] ] ] ].

normadp1-norm-adposition-lex := norm-adposition-lex &
  [ SYNSEM.LOCAL.CAT.HEAD.INIT + ].

normadp2-norm-adposition-lex := norm-adposition-lex &
  [ SYNSEM.LOCAL.CAT.HEAD.INIT + ].

;;; Determiners
;;; SPEC is non-empty, and already specified by basic-determiner-lex.

determiner-lex := basic-determiner-lex & basic-non-wh-word-lex & norm-zero-arg & non-mod-lex-item &
  [ SYNSEM.LOCAL.CAT.VAL [ SPR < >,
                           COMPS < >,
                           SUBJ < > ] ].

def-art-determiner-lex := determiner-lex & no-icons-lex-item &
  [ SYNSEM [ L-QUE -,
             LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.PER 3rd ] ].

wh-determiner-lex := basic-wh-word-lex & basic-determiner-lex & non-mod-lex-item & zero-arg-nonslash &
  [ SYNSEM [ LOCAL.CAT.VAL [ SPR < >,
                             SPEC.FIRST.LOCAL.CONT.HOOK.INDEX #arg0,
                             COMPS < >,
                             SUBJ < > ],
             NON-LOCAL.QUE.LIST < #arg0 > ] ].

qual-determiner-lex := wh-determiner-lex & one-icons-lex-item &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CONT.HOOK.INDEX.PNG [ PER 3rd,
                                                                NUM singular ] ].

que-determiner-lex := wh-determiner-lex & one-icons-lex-item &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.PER 3rd ].

cada-determiner-lex := determiner-lex & no-icons-lex-item &
  [ SYNSEM [ L-QUE -,
             LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CONT.HOOK.INDEX.PNG [ PER 3rd,
                                                                  NUM singular ] ] ].

todo-determiner-lex := determiner-lex & no-icons-lex-item &
  [ SYNSEM [ L-QUE -,
             LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.PER 3rd ] ].

indef-art-determiner-lex := determiner-lex & no-icons-lex-item &
  [ SYNSEM [ L-QUE -,
             LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.PER 3rd ] ].

algum-determiner-lex := determiner-lex & no-icons-lex-item &
  [ SYNSEM.L-QUE - ].

dem-prox-determiner-lex := determiner-lex & no-icons-lex-item &
  [ SYNSEM [ L-QUE -,
             LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.PER 3rd ] ].

dem-med-determiner-lex := determiner-lex & no-icons-lex-item &
  [ SYNSEM [ L-QUE -,
             LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.PER 3rd ] ].

dem-dist-determiner-lex := determiner-lex & no-icons-lex-item &
  [ SYNSEM [ L-QUE -,
             LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.PER 3rd ] ].

outro-determiner-lex := determiner-lex & no-icons-lex-item &
  [ SYNSEM [ L-QUE -,
             LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.PER 3rd ] ].

pouco-determiner-lex := determiner-lex & no-icons-lex-item &
  [ SYNSEM [ L-QUE -,
             LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.PER 3rd ] ].

card-2-determiner-lex := determiner-lex & no-icons-lex-item &
  [ SYNSEM [ L-QUE -,
             LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CONT.HOOK.INDEX.PNG [ NUM plural,
                                                                  PER 3rd,
                                                                  GEND masculine ] ] ].

card-3-determiner-lex := determiner-lex & no-icons-lex-item &
  [ SYNSEM [ L-QUE -,
             LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CONT.HOOK.INDEX.PNG [ NUM plural,
                                                                  PER 3rd ] ] ].

quanto-determiner-lex := wh-determiner-lex & one-icons-lex-item &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CONT.HOOK.INDEX.PNG [ PER 3rd,
                                                                NUM singular,
                                                                GEND masculine ] ].

qualquer-determiner-lex := determiner-lex & no-icons-lex-item &
  [ SYNSEM.L-QUE - ].

certo-determiner-lex := determiner-lex & no-icons-lex-item &
  [ SYNSEM.L-QUE - ].

muito-determiner-lex := determiner-lex & no-icons-lex-item &
  [ SYNSEM.L-QUE - ].

ambos-determiner-lex := determiner-lex & no-icons-lex-item &
  [ SYNSEM [ L-QUE -,
             LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CONT.HOOK.INDEX.PNG [ NUM plural,
                                                                  PER 3rd,
                                                                  GEND masculine ] ] ].

tal-determiner-lex := determiner-lex & no-icons-lex-item &
  [ SYNSEM.L-QUE - ].

vários-determiner-lex := determiner-lex & no-icons-lex-item &
  [ SYNSEM [ L-QUE -,
             LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CONT.HOOK.INDEX.PNG [ NUM plural,
                                                                  GEND masculine,
                                                                  PER 3rd ] ] ].

nenhum-determiner-lex := determiner-lex & no-icons-lex-item &
  [ SYNSEM [ L-QUE -,
             LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.PER 3rd ] ].

diversos-determiner-lex := determiner-lex & no-icons-lex-item &
  [ SYNSEM [ L-QUE -,
             LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CONT.HOOK.INDEX.PNG [ NUM plural,
                                                                  GEND masculine,
                                                                  PER 3rd ] ] ].

non-infl-form-determiner-lex := determiner-lex & no-icons-lex-item & det-num-rule-dtr &
  [ SYNSEM.L-QUE -,
    INFLECTED [ DET-GEND-FLAG -,
                DET-NUM-FLAG - ] ].

;;; Adverbs

; Type for negative adverbs.
; 
; This adverb should go through a specialized phrase structure rule
;                           included with this grammar.

neg-adv-lex := basic-scopal-adverb-lex &
  [ SYNSEM.LOCAL.CAT [ VAL [ SPR < >,
                             COMPS < >,
                             SUBJ < >,
                             SPEC < > ],
                       POSTHEAD -,
                       HEAD.MOD < [ LOCAL.CAT [ HEAD verb,
                                                VAL [ SUBJ cons,
                                                      COMPS null ] ] ] > ] ].

;;;;;;;;;;;;;;;;;;;
;;; Lexical Rules
;;;;;;;;;;;;;;;;;;;

high-or-mid-nominalization-lex-rule := cat-change-with-ccont-lex-rule & same-cont-lex-rule &
  [ SYNSEM.LOCAL [ CONT.HOOK.INDEX event,
                   CAT [ HEAD verb &
                              [ NMZ +,
                                MOD #mod ],
                         VAL [ SUBJ #subj,
                               COMPS #comps,
                               SPR #spr,
                               SPEC #spec ],
                         MC #mc,
                         MKG #mkg,
                         HC-LIGHT #hc-light,
                         POSTHEAD #posthead ] ],
    DTR.SYNSEM.LOCAL.CAT [ HEAD.MOD #mod,
                           VAL [ SUBJ #subj,
                                 COMPS #comps,
                                 SPR #spr,
                                 SPEC #spec ],
                           MC #mc,
                           MKG #mkg,
                           HC-LIGHT #hc-light,
                           POSTHEAD #posthead ],
    C-CONT [ RELS.LIST < >,
             HCONS.LIST < > ] ].

;;; Intermediate rule types

det-num-rule-dtr := word-or-lexrule.
a-num-rule-dtr := word-or-lexrule.
refl-rule-dtr := word-or-lexrule.
tmp-rule-dtr := word-or-lexrule.

;;; Lexical rule types

n-num-lex-rule-super := add-only-no-ccont-rule &
  [ INFLECTED [ N-NUM-FLAG +,
                REFL-FLAG #refl,
                DET-GEND-FLAG #det-gend,
                UNIFORM-ADJ-FLAG #uniform-adj,
                A-GEND-FLAG #a-gend,
                DET-NUM-FLAG #det-num,
                NON-UNIFORM-ADJ-FLAG #non-uniform-adj,
                TMP-FLAG #tmp,
                AUX-OR-ESTAR-AUX-OR-IR-AUX-OR-NONINH-REFL-VERB-OR-TER-AUX-FLAG #aux-or-estar-aux-or-ir-aux-or-noninh-refl-verb-or-ter-aux,
                A-NUM-FLAG #a-num,
                COP-TMP-FLAG #cop-tmp,
                INH-REFL-VERB-FLAG #inh-refl-verb ],
    DTR common-noun-lex &
        [ INFLECTED [ REFL-FLAG #refl,
                      DET-GEND-FLAG #det-gend,
                      UNIFORM-ADJ-FLAG #uniform-adj,
                      A-GEND-FLAG #a-gend,
                      DET-NUM-FLAG #det-num,
                      NON-UNIFORM-ADJ-FLAG #non-uniform-adj,
                      TMP-FLAG #tmp,
                      AUX-OR-ESTAR-AUX-OR-IR-AUX-OR-NONINH-REFL-VERB-OR-TER-AUX-FLAG #aux-or-estar-aux-or-ir-aux-or-noninh-refl-verb-or-ter-aux,
                      A-NUM-FLAG #a-num,
                      COP-TMP-FLAG #cop-tmp,
                      INH-REFL-VERB-FLAG #inh-refl-verb ] ] ].

n-sg-lex-rule := const-lex-rule & n-num-lex-rule-super &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NUM singular ].

n-pl-lex-rule := infl-lex-rule & n-num-lex-rule-super &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NUM plural ].

tmp-lex-rule-super := add-only-no-ccont-rule & refl-rule-dtr &
  [ INFLECTED [ TMP-FLAG +,
                N-NUM-FLAG #n-num,
                REFL-FLAG #refl,
                DET-GEND-FLAG #det-gend,
                UNIFORM-ADJ-FLAG #uniform-adj,
                A-GEND-FLAG #a-gend,
                DET-NUM-FLAG #det-num,
                NON-UNIFORM-ADJ-FLAG #non-uniform-adj,
                AUX-OR-ESTAR-AUX-OR-IR-AUX-OR-NONINH-REFL-VERB-OR-TER-AUX-FLAG #aux-or-estar-aux-or-ir-aux-or-noninh-refl-verb-or-ter-aux,
                A-NUM-FLAG #a-num,
                COP-TMP-FLAG #cop-tmp,
                INH-REFL-VERB-FLAG #inh-refl-verb ],
    DTR tmp-rule-dtr &
        [ INFLECTED [ N-NUM-FLAG #n-num,
                      REFL-FLAG #refl,
                      DET-GEND-FLAG #det-gend,
                      UNIFORM-ADJ-FLAG #uniform-adj,
                      A-GEND-FLAG #a-gend,
                      DET-NUM-FLAG #det-num,
                      NON-UNIFORM-ADJ-FLAG #non-uniform-adj,
                      AUX-OR-ESTAR-AUX-OR-IR-AUX-OR-NONINH-REFL-VERB-OR-TER-AUX-FLAG #aux-or-estar-aux-or-ir-aux-or-noninh-refl-verb-or-ter-aux,
                      A-NUM-FLAG #a-num,
                      COP-TMP-FLAG #cop-tmp,
                      INH-REFL-VERB-FLAG #inh-refl-verb ] ] ].

perf-ind-lex-rule := infl-lex-rule & tmp-lex-rule-super &
  [ SYNSEM.LOCAL [ CONT.HOOK.INDEX.E [ TENSE past,
                                       MOOD indicative ],
                   CAT.HEAD.FORM finite ] ].

perf-ind-1sg-lex-rule := 1sg-lex-rule & perf-ind-lex-rule.

perf-ind-3sg-lex-rule := 3sg-lex-rule & perf-ind-lex-rule.

perf-ind-3pl-lex-rule := 3pl-lex-rule & perf-ind-lex-rule.

infl-inf-lex-rule := infl-lex-rule & tmp-lex-rule-super &
  [ SYNSEM.LOCAL [ CAT.HEAD.FORM infl_infinitive,
                   CONT.HOOK.INDEX.E.TENSE present ] ].

infl-inf-3pl-lex-rule := 3pl-lex-rule & infl-inf-lex-rule.

pres-ind-lex-rule := infl-lex-rule & tmp-lex-rule-super &
  [ SYNSEM.LOCAL [ CONT.HOOK.INDEX.E [ TENSE present,
                                       MOOD indicative ],
                   CAT.HEAD.FORM finite ] ].

infl-inf-3sg-lex-rule := 3sg-lex-rule & infl-inf-lex-rule.

3sg-lex-rule := infl-lex-rule & tmp-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG [ PER 3rd,
                                                                NUM singular ] ].

pres-ind-3sg-lex-rule := 3sg-lex-rule & pres-ind-lex-rule.

3pl-lex-rule := infl-lex-rule & tmp-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG [ NUM plural,
                                                                PER 3rd ] ].

pres-ind-3pl-lex-rule := 3pl-lex-rule & pres-ind-lex-rule.

inf-lex-rule := const-lex-rule & tmp-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.HEAD.FORM infinitive ].

past-part-lex-rule := infl-lex-rule & tmp-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.HEAD.FORM past_participle ].

pres-part-lex-rule := infl-lex-rule & tmp-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.HEAD.FORM present_participle ].

1sg-lex-rule := infl-lex-rule & tmp-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG [ PER 1st,
                                                                NUM singular ] ].

1pl-lex-rule := infl-lex-rule & tmp-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG [ NUM plural,
                                                                PER 1st ] ].

2sg-lex-rule := infl-lex-rule & tmp-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG [ NUM singular,
                                                                PER 2nd ] ].

2pl-lex-rule := infl-lex-rule & tmp-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG [ PER 2nd,
                                                                NUM plural ] ].

pres-ind-1sg-lex-rule := 1sg-lex-rule & pres-ind-lex-rule.

pres-ind-1pl-lex-rule := 1pl-lex-rule & pres-ind-lex-rule.

pres-ind-2sg-lex-rule := 2sg-lex-rule & pres-ind-lex-rule.

pres-ind-2pl-lex-rule := 2pl-lex-rule & pres-ind-lex-rule.

ind-mood-lex-rule := infl-lex-rule & tmp-lex-rule-super &
  [ SYNSEM.LOCAL [ CAT.HEAD.FORM finite,
                   CONT.HOOK.INDEX.E.MOOD indicative ] ].

subj-mood-lex-rule := infl-lex-rule & tmp-lex-rule-super &
  [ SYNSEM.LOCAL [ CONT.HOOK.INDEX.E.MOOD subjunctive,
                   CAT.HEAD.FORM finite ] ].

pres-subj-lex-rule := subj-mood-lex-rule &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE present ].

impf-subj-lex-rule := subj-mood-lex-rule &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE imperfect ].

fut-subj-lex-rule := subj-mood-lex-rule &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE future ].

impf-ind-lex-rule := ind-mood-lex-rule &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE imperfect ].

fut-ind-lex-rule := ind-mood-lex-rule &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE present-future ].

fut-pret-lex-rule := ind-mood-lex-rule &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE preterite-future ].

pluperf-lex-rule := ind-mood-lex-rule &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE pluperfect ].

pres-subj-1sg-lex-rule := 1sg-lex-rule & pres-subj-lex-rule.

pres-subj-1pl-lex-rule := 1pl-lex-rule & pres-subj-lex-rule.

pres-subj-3sg-lex-rule := 3sg-lex-rule & pres-subj-lex-rule.

pres-subj-3pl-lex-rule := 3pl-lex-rule & pres-subj-lex-rule.

pres-subj-2sg-lex-rule := 2sg-lex-rule & pres-subj-lex-rule.

pres-subj-2pl-lex-rule := 2pl-lex-rule & pres-subj-lex-rule.

fut-ind-1sg-lex-rule := 1sg-lex-rule & fut-ind-lex-rule.

fut-ind-1pl-lex-rule := 1pl-lex-rule & fut-ind-lex-rule.

fut-ind-2sg-lex-rule := 2sg-lex-rule & fut-ind-lex-rule.

fut-ind-3sg-lex-rule := 3sg-lex-rule & fut-ind-lex-rule.

fut-ind-3pl-lex-rule := 3pl-lex-rule & fut-ind-lex-rule.

fut-ind-2pl-lex-rule := 2pl-lex-rule & fut-ind-lex-rule.

impf-ind-1sg-lex-rule := 1sg-lex-rule & impf-ind-lex-rule.

impf-ind-1pl-lex-rule := 1pl-lex-rule & impf-ind-lex-rule.

impf-ind-3sg-lex-rule := 3sg-lex-rule & impf-ind-lex-rule.

impf-ind-2sg-lex-rule := 2sg-lex-rule & impf-ind-lex-rule.

impf-ind-2pl-lex-rule := 2pl-lex-rule & impf-ind-lex-rule.

impf-ind-3pl-lex-rule := 3pl-lex-rule & impf-ind-lex-rule.

fut-pret-1sg-lex-rule := 1sg-lex-rule & fut-pret-lex-rule.

fut-pret-1pl-lex-rule := 1pl-lex-rule & fut-pret-lex-rule.

fut-pret-2sg-lex-rule := 2sg-lex-rule & fut-pret-lex-rule.

fut-pret-2pl-lex-rule := 2pl-lex-rule & fut-pret-lex-rule.

fut-pret-3sg-lex-rule := 3sg-lex-rule & fut-pret-lex-rule.

fut-pret-3pl-lex-rule := 3pl-lex-rule & fut-pret-lex-rule.

pluperf-1sg-lex-rule := 1sg-lex-rule & pluperf-lex-rule.

pluperf-1pl-lex-rule := 1pl-lex-rule & pluperf-lex-rule.

pluperf-2sg-lex-rule := 2sg-lex-rule & fut-pret-lex-rule.

pluperf-3sg-lex-rule := 3sg-lex-rule & fut-pret-lex-rule.

pluperf-3pl-lex-rule := 3pl-lex-rule & fut-pret-lex-rule.

pluperf-2pl-lex-rule := 2pl-lex-rule & pluperf-lex-rule.

impf-subj-1sg-lex-rule := 1sg-lex-rule & impf-subj-lex-rule.

impf-subj-1pl-lex-rule := 1pl-lex-rule & impf-subj-lex-rule.

impf-subj-3sg-lex-rule := 3sg-lex-rule & impf-subj-lex-rule.

impf-subj-3pl-lex-rule := 3pl-lex-rule & impf-subj-lex-rule.

impf-subj-2sg-lex-rule := 2sg-lex-rule & impf-subj-lex-rule.

impf-subj-2pl-lex-rule := 2pl-lex-rule & impf-subj-lex-rule.

fut-subj-1sg-lex-rule := 1sg-lex-rule & fut-subj-lex-rule.

fut-subj-1pl-lex-rule := 1pl-lex-rule & fut-subj-lex-rule.

fut-subj-3sg-lex-rule := 3sg-lex-rule & fut-subj-lex-rule.

fut-subj-3pl-lex-rule := 3pl-lex-rule & fut-subj-lex-rule.

fut-subj-2sg-lex-rule := 2sg-lex-rule & fut-subj-lex-rule.

fut-subj-2pl-lex-rule := 2pl-lex-rule & fut-subj-lex-rule.

perf-ind-2sg-lex-rule := 2sg-lex-rule & perf-ind-lex-rule.

perf-ind-2pl-lex-rule := 2pl-lex-rule & perf-ind-lex-rule.

perf-ind-1pl-lex-rule := 1pl-lex-rule & perf-ind-lex-rule.

infl-inf-2sg-lex-rule := 2sg-lex-rule & infl-inf-lex-rule.

infl-inf-2pl-lex-rule := 2pl-lex-rule & infl-inf-lex-rule.

infl-inf-1pl-lex-rule := 1pl-lex-rule & infl-inf-lex-rule.

infl-inf-1sg-lex-rule := 1sg-lex-rule & infl-inf-lex-rule.

refl-lex-rule-super := add-only-no-ccont-rule &
  [ INFLECTED [ REFL-FLAG +,
                N-NUM-FLAG #n-num,
                DET-GEND-FLAG #det-gend,
                UNIFORM-ADJ-FLAG #uniform-adj,
                A-GEND-FLAG #a-gend,
                DET-NUM-FLAG #det-num,
                NON-UNIFORM-ADJ-FLAG #non-uniform-adj,
                TMP-FLAG #tmp,
                AUX-OR-ESTAR-AUX-OR-IR-AUX-OR-NONINH-REFL-VERB-OR-TER-AUX-FLAG #aux-or-estar-aux-or-ir-aux-or-noninh-refl-verb-or-ter-aux,
                A-NUM-FLAG #a-num,
                COP-TMP-FLAG #cop-tmp,
                INH-REFL-VERB-FLAG #inh-refl-verb ],
    DTR refl-rule-dtr &
        [ INFLECTED [ N-NUM-FLAG #n-num,
                      DET-GEND-FLAG #det-gend,
                      UNIFORM-ADJ-FLAG #uniform-adj,
                      A-GEND-FLAG #a-gend,
                      DET-NUM-FLAG #det-num,
                      NON-UNIFORM-ADJ-FLAG #non-uniform-adj,
                      TMP-FLAG #tmp,
                      AUX-OR-ESTAR-AUX-OR-IR-AUX-OR-NONINH-REFL-VERB-OR-TER-AUX-FLAG #aux-or-estar-aux-or-ir-aux-or-noninh-refl-verb-or-ter-aux,
                      A-NUM-FLAG #a-num,
                      COP-TMP-FLAG #cop-tmp,
                      INH-REFL-VERB-FLAG #inh-refl-verb ] ] ].

zero-refl-mark-lex-rule := const-lex-rule & refl-lex-rule-super &
  [ DTR.INFLECTED.INH-REFL-VERB-FLAG na ].

refl-mark-lex-rule := infl-lex-rule & refl-lex-rule-super &
  [ DTR.INFLECTED.AUX-OR-ESTAR-AUX-OR-IR-AUX-OR-NONINH-REFL-VERB-OR-TER-AUX-FLAG na ].

refl-mark-1s-lex-rule := refl-mark-1st-lex-rule & refl-mark-sg-lex-rule.

refl-mark-3-lex-rule := refl-mark-3rd-lex-rule.

refl-mark-sg-lex-rule := refl-mark-lex-rule &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.NUM singular ].

refl-mark-pl-lex-rule := refl-mark-lex-rule &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.NUM plural ].

refl-mark-1st-lex-rule := refl-mark-lex-rule &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.PER 1st ].

refl-mark-2nd-lex-rule := refl-mark-lex-rule.

refl-mark-3rd-lex-rule := refl-mark-lex-rule &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.PER 3rd ].

refl-mark-2s-lex-rule := refl-mark-2nd-lex-rule & refl-mark-sg-lex-rule.

refl-mark-2p-lex-rule := refl-mark-2nd-lex-rule & refl-mark-pl-lex-rule.

refl-mark-1p-lex-rule := refl-mark-1st-lex-rule & refl-mark-pl-lex-rule.

det-gend-lex-rule-super := add-only-no-ccont-rule & det-num-rule-dtr &
  [ INFLECTED [ DET-GEND-FLAG +,
                N-NUM-FLAG #n-num,
                REFL-FLAG #refl,
                UNIFORM-ADJ-FLAG #uniform-adj,
                A-GEND-FLAG #a-gend,
                DET-NUM-FLAG #det-num,
                NON-UNIFORM-ADJ-FLAG #non-uniform-adj,
                TMP-FLAG #tmp,
                AUX-OR-ESTAR-AUX-OR-IR-AUX-OR-NONINH-REFL-VERB-OR-TER-AUX-FLAG #aux-or-estar-aux-or-ir-aux-or-noninh-refl-verb-or-ter-aux,
                A-NUM-FLAG #a-num,
                COP-TMP-FLAG #cop-tmp,
                INH-REFL-VERB-FLAG #inh-refl-verb ],
    DTR non-infl-form-determiner-lex &
        [ INFLECTED [ N-NUM-FLAG #n-num,
                      REFL-FLAG #refl,
                      UNIFORM-ADJ-FLAG #uniform-adj,
                      A-GEND-FLAG #a-gend,
                      DET-NUM-FLAG #det-num,
                      NON-UNIFORM-ADJ-FLAG #non-uniform-adj,
                      TMP-FLAG #tmp,
                      AUX-OR-ESTAR-AUX-OR-IR-AUX-OR-NONINH-REFL-VERB-OR-TER-AUX-FLAG #aux-or-estar-aux-or-ir-aux-or-noninh-refl-verb-or-ter-aux,
                      A-NUM-FLAG #a-num,
                      COP-TMP-FLAG #cop-tmp,
                      INH-REFL-VERB-FLAG #inh-refl-verb ] ] ].

det-fem-lex-rule := det-gend-lex-rule-super & infl-lex-rule &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.GEND feminine ].

det-masc-lex-rule := const-lex-rule & det-gend-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.GEND masculine ].

det-num-lex-rule-super := add-only-no-ccont-rule &
  [ INFLECTED [ DET-NUM-FLAG +,
                N-NUM-FLAG #n-num,
                REFL-FLAG #refl,
                DET-GEND-FLAG #det-gend,
                UNIFORM-ADJ-FLAG #uniform-adj,
                A-GEND-FLAG #a-gend,
                NON-UNIFORM-ADJ-FLAG #non-uniform-adj,
                TMP-FLAG #tmp,
                AUX-OR-ESTAR-AUX-OR-IR-AUX-OR-NONINH-REFL-VERB-OR-TER-AUX-FLAG #aux-or-estar-aux-or-ir-aux-or-noninh-refl-verb-or-ter-aux,
                A-NUM-FLAG #a-num,
                COP-TMP-FLAG #cop-tmp,
                INH-REFL-VERB-FLAG #inh-refl-verb ],
    DTR det-num-rule-dtr &
        [ INFLECTED [ N-NUM-FLAG #n-num,
                      REFL-FLAG #refl,
                      DET-GEND-FLAG #det-gend,
                      UNIFORM-ADJ-FLAG #uniform-adj,
                      A-GEND-FLAG #a-gend,
                      NON-UNIFORM-ADJ-FLAG #non-uniform-adj,
                      TMP-FLAG #tmp,
                      AUX-OR-ESTAR-AUX-OR-IR-AUX-OR-NONINH-REFL-VERB-OR-TER-AUX-FLAG #aux-or-estar-aux-or-ir-aux-or-noninh-refl-verb-or-ter-aux,
                      A-NUM-FLAG #a-num,
                      COP-TMP-FLAG #cop-tmp,
                      INH-REFL-VERB-FLAG #inh-refl-verb ] ] ].

det-pl-lex-rule := det-num-lex-rule-super & infl-lex-rule &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.NUM plural ].

det-sg-lex-rule := const-lex-rule & det-num-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.NUM singular ].

a-gend-lex-rule-super := a-num-rule-dtr & add-only-no-ccont-rule &
  [ INFLECTED [ A-GEND-FLAG +,
                N-NUM-FLAG #n-num,
                REFL-FLAG #refl,
                DET-GEND-FLAG #det-gend,
                UNIFORM-ADJ-FLAG #uniform-adj,
                DET-NUM-FLAG #det-num,
                NON-UNIFORM-ADJ-FLAG #non-uniform-adj,
                TMP-FLAG #tmp,
                AUX-OR-ESTAR-AUX-OR-IR-AUX-OR-NONINH-REFL-VERB-OR-TER-AUX-FLAG #aux-or-estar-aux-or-ir-aux-or-noninh-refl-verb-or-ter-aux,
                A-NUM-FLAG #a-num,
                COP-TMP-FLAG #cop-tmp,
                INH-REFL-VERB-FLAG #inh-refl-verb ],
    DTR non-infl-form-adj-lex &
        [ INFLECTED [ N-NUM-FLAG #n-num,
                      REFL-FLAG #refl,
                      DET-GEND-FLAG #det-gend,
                      UNIFORM-ADJ-FLAG #uniform-adj,
                      DET-NUM-FLAG #det-num,
                      NON-UNIFORM-ADJ-FLAG #non-uniform-adj,
                      TMP-FLAG #tmp,
                      AUX-OR-ESTAR-AUX-OR-IR-AUX-OR-NONINH-REFL-VERB-OR-TER-AUX-FLAG #aux-or-estar-aux-or-ir-aux-or-noninh-refl-verb-or-ter-aux,
                      A-NUM-FLAG #a-num,
                      COP-TMP-FLAG #cop-tmp,
                      INH-REFL-VERB-FLAG #inh-refl-verb ] ] ].

unmarked-gender-lex-rule := a-gend-lex-rule-super & const-lex-rule &
  [ DTR.INFLECTED.NON-UNIFORM-ADJ-FLAG na ].

marked-gender-lex-rule := a-gend-lex-rule-super &
  [ DTR.INFLECTED.UNIFORM-ADJ-FLAG na ].

masc-lex-rule := const-lex-rule & marked-gender-lex-rule &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG.PNG.GEND masculine ].

fem-lex-rule := infl-lex-rule & marked-gender-lex-rule &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG.PNG.GEND feminine ].

a-num-lex-rule-super := add-only-no-ccont-rule &
  [ INFLECTED [ A-NUM-FLAG +,
                N-NUM-FLAG #n-num,
                REFL-FLAG #refl,
                DET-GEND-FLAG #det-gend,
                UNIFORM-ADJ-FLAG #uniform-adj,
                A-GEND-FLAG #a-gend,
                DET-NUM-FLAG #det-num,
                NON-UNIFORM-ADJ-FLAG #non-uniform-adj,
                TMP-FLAG #tmp,
                AUX-OR-ESTAR-AUX-OR-IR-AUX-OR-NONINH-REFL-VERB-OR-TER-AUX-FLAG #aux-or-estar-aux-or-ir-aux-or-noninh-refl-verb-or-ter-aux,
                COP-TMP-FLAG #cop-tmp,
                INH-REFL-VERB-FLAG #inh-refl-verb ],
    DTR a-num-rule-dtr &
        [ INFLECTED [ N-NUM-FLAG #n-num,
                      REFL-FLAG #refl,
                      DET-GEND-FLAG #det-gend,
                      UNIFORM-ADJ-FLAG #uniform-adj,
                      A-GEND-FLAG #a-gend,
                      DET-NUM-FLAG #det-num,
                      NON-UNIFORM-ADJ-FLAG #non-uniform-adj,
                      TMP-FLAG #tmp,
                      AUX-OR-ESTAR-AUX-OR-IR-AUX-OR-NONINH-REFL-VERB-OR-TER-AUX-FLAG #aux-or-estar-aux-or-ir-aux-or-noninh-refl-verb-or-ter-aux,
                      COP-TMP-FLAG #cop-tmp,
                      INH-REFL-VERB-FLAG #inh-refl-verb ] ] ].

a-pl-lex-rule := a-num-lex-rule-super & infl-lex-rule &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG.PNG.NUM plural ].

a-sg-lex-rule := a-num-lex-rule-super & const-lex-rule &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG.PNG.NUM singular ].

cop-tmp-lex-rule-super := add-only-no-ccont-rule & infl-lex-rule &
  [ INFLECTED [ COP-TMP-FLAG +,
                N-NUM-FLAG #n-num,
                REFL-FLAG #refl,
                DET-GEND-FLAG #det-gend,
                UNIFORM-ADJ-FLAG #uniform-adj,
                A-GEND-FLAG #a-gend,
                DET-NUM-FLAG #det-num,
                NON-UNIFORM-ADJ-FLAG #non-uniform-adj,
                TMP-FLAG #tmp,
                AUX-OR-ESTAR-AUX-OR-IR-AUX-OR-NONINH-REFL-VERB-OR-TER-AUX-FLAG #aux-or-estar-aux-or-ir-aux-or-noninh-refl-verb-or-ter-aux,
                A-NUM-FLAG #a-num,
                INH-REFL-VERB-FLAG #inh-refl-verb ],
    DTR cop-lex &
        [ INFLECTED [ N-NUM-FLAG #n-num,
                      REFL-FLAG #refl,
                      DET-GEND-FLAG #det-gend,
                      UNIFORM-ADJ-FLAG #uniform-adj,
                      A-GEND-FLAG #a-gend,
                      DET-NUM-FLAG #det-num,
                      NON-UNIFORM-ADJ-FLAG #non-uniform-adj,
                      TMP-FLAG #tmp,
                      AUX-OR-ESTAR-AUX-OR-IR-AUX-OR-NONINH-REFL-VERB-OR-TER-AUX-FLAG #aux-or-estar-aux-or-ir-aux-or-noninh-refl-verb-or-ter-aux,
                      A-NUM-FLAG #a-num,
                      INH-REFL-VERB-FLAG #inh-refl-verb ] ] ].

cop-ind-lex-rule := cop-tmp-lex-rule-super &
  [ SYNSEM.LOCAL [ CONT.HOOK.INDEX.E.MOOD indicative,
                   CAT.HEAD.FORM finite ] ].

cop-subj-lex-rule := cop-tmp-lex-rule-super &
  [ SYNSEM.LOCAL [ CONT.HOOK.INDEX.E.MOOD subjunctive,
                   CAT.HEAD.FORM finite ] ].

cop-pres-ind-lex-rule := cop-ind-lex-rule &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE present ].

cop-pres-subj-lex-rule := cop-subj-lex-rule &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE present ].

cop-perf-lex-rule := cop-ind-lex-rule &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE perfect ].

cop-imperf-lex-rule := cop-ind-lex-rule &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE imperfect ].

cop-pqp-lex-rule := cop-ind-lex-rule &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE pluperfect ].

cop-fut-ind-lex-rule := cop-ind-lex-rule &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE present-future ].

cop-fut-pret-lex-rule := cop-ind-lex-rule &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE preterite-future ].

cop-imperf-subj-lex-rule := cop-subj-lex-rule &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE imperfect ].

cop-fut-subj-lex-rule := cop-subj-lex-rule &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE future ].

cop-past-part-lex-rule := cop-tmp-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.HEAD.FORM past_participle ].

cop-pres-part-lex-rule := cop-tmp-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.HEAD.FORM present_participle ].

cop-inf-lex-rule := cop-tmp-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.HEAD.FORM infinitive ].

cop-infl-inf-lex-rule := cop-tmp-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.HEAD.FORM infl_infinitive ].

cop-1-lex-rule := cop-tmp-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.PER 1st ].

cop-2-lex-rule := cop-tmp-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.PER 2nd ].

cop-3-lex-rule := cop-tmp-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.PER 3rd ].

cop-sg-lex-rule := cop-tmp-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.NUM singular ].

cop-pl-lex-rule := cop-tmp-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.NUM plural ].

cop-1sg-lex-rule := cop-1-lex-rule & cop-sg-lex-rule.

cop-2sg-lex-rule := cop-2-lex-rule & cop-sg-lex-rule.

cop-3sg-lex-rule := cop-3-lex-rule & cop-sg-lex-rule.

cop-1pl-lex-rule := cop-1-lex-rule & cop-pl-lex-rule.

cop-2pl-lex-rule := cop-2-lex-rule & cop-pl-lex-rule.

cop-3pl-lex-rule := cop-3-lex-rule & cop-pl-lex-rule.

cop-pres-ind-1sg-lex-rule := cop-1sg-lex-rule & cop-pres-ind-lex-rule.

cop-pres-ind-2sg-lex-rule := cop-2sg-lex-rule & cop-pres-ind-lex-rule.

cop-pres-ind-3sg-lex-rule := cop-3sg-lex-rule & cop-pres-ind-lex-rule.

cop-pres-ind-1pl-lex-rule := cop-1pl-lex-rule & cop-pres-ind-lex-rule.

cop-pres-ind-2pl-lex-rule := cop-2pl-lex-rule & cop-pres-ind-lex-rule.

cop-pres-ind-3pl-lex-rule := cop-3pl-lex-rule & cop-pres-ind-lex-rule.

cop-pres-subj-1sg-lex-rule := cop-1sg-lex-rule & cop-pres-subj-lex-rule.

cop-imperf-ind-1sg-lex-rule := cop-1sg-lex-rule & cop-imperf-lex-rule.

cop-imperf-subj-1sg-lex-rule := cop-1sg-lex-rule & cop-imperf-subj-lex-rule.

cop-perf-1sg-lex-rule := cop-1sg-lex-rule & cop-perf-lex-rule.

cop-fut-ind-1sg-lex-rule := cop-1sg-lex-rule & cop-fut-ind-lex-rule.

cop-fut-subj-1sg-lex-rule := cop-1sg-lex-rule & cop-fut-subj-lex-rule.

cop-pqp-1sg-lex-rule := cop-1sg-lex-rule & cop-pqp-lex-rule.

cop-fut-pret-1sg-lex-rule := cop-1sg-lex-rule & cop-fut-pret-lex-rule.

cop-infl-inf-2sg-lex-rule := cop-2sg-lex-rule & cop-infl-inf-lex-rule.

;;;;;;;;;;;;;;;;;;;
;;; Phrasal Types
;;;;;;;;;;;;;;;;;;;

my-head-adj-phrase := head-adj-int-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD +nvr,
                                VAL [ SUBJ clist,
                                      COMPS clist ] ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD +jrp,
                                    VAL.COMPS < > ] ].

my-adj-head-phrase := adj-head-int-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD +nvr,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD +jrp,
                                    VAL.COMPS < > ] ].

high-no-rel-nominalized-clause-phrase := unary-phrase &
  [ SYNSEM [ NON-LOCAL #nl,
             LOCAL [ CAT [ HEAD noun &
                                [ NMZ +,
                                  MOD < > ],
                           VAL [ COMPS < >,
                                 SUBJ < >,
                                 SPR < >,
                                 SPEC < > ] ],
                     COORD - ] ],
    C-CONT [ RELS.LIST < >,
             HCONS.LIST < >,
             HOOK [ XARG #xarg,
                    LTOP #ltop ] ],
    ARGS < [ SYNSEM [ NON-LOCAL #nl,
                      LOCAL [ CAT [ HEAD verb &
                                         [ NMZ + ],
                                    VAL [ COMPS < >,
                                          SUBJ < >,
                                          SPR < >,
                                          SPEC < > ] ],
                              CONT.HOOK [ XARG #xarg,
                                          LTOP #ltop ],
                              COORD - ] ] ] > ].

;Constraint on MC used to be part of matrix.tdl
;;it applies to all wo implementations, except for v2

head-comp-phrase := basic-head-1st-comp-phrase & head-initial &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.INIT + ].

subj-head-phrase := decl-head-subj-phrase & head-final &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < >,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.QUE.LIST < > ].

; Bare NP phrase.  Consider modifying the PRED value of the quantifier relation
; introduced to match the semantic effect of bare NPs in your language.

bare-np-phrase := basic-bare-np-phrase &
  [ C-CONT.RELS.LIST < [ PRED "exist_q_rel" ] >,
    SYNSEM.LIGHT - ].

;;; Head Adjunct rules

; For intersective adjuncts with underspecified attachment locations:

;;; Wh-question-related phrasal types

wh-ques-phrase := basic-head-filler-phrase & interrogative-clause & head-final &
  [ SYNSEM [ LOCAL.CAT [ WH.BOOL +,
                         MC bool,
                         VAL #val,
                         HEAD verb ],
             NON-LOCAL.QUE.LIST < > ],
    NON-HEAD-DTR.SYNSEM [ NON-LOCAL [ QUE.LIST < ref-ind >,
                                      SLASH.LIST < >,
                                      REL.LIST < > ],
                          LOCAL.CONT.HOOK.ICONS-KEY focus ],
    HEAD-DTR.SYNSEM.LOCAL.CAT [ VAL #val &
                                    [ SUBJ < >,
                                      COMPS < > ],
                                MC na-or-+ ] ].

; Complement extraction

; Adjunct extraction

basic-filler-phrase :+ [ SYNSEM.NON-LOCAL.SLASH.LIST < >,
    ARGS < [ SYNSEM [ LOCAL #slash,
                      NON-LOCAL.SLASH.LIST < > ] ],
           [ SYNSEM.NON-LOCAL.SLASH.LIST < #slash > ] > ].

; In-situ interrogative clause.
